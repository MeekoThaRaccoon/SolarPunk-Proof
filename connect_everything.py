#!/usr/bin/env python3
"""
SOLARPUNK-MOLTBOT UNIVERSAL CONNECTOR
Proof of (Human √ó AI)^Simultaneity √ó Network Effect
"""

import requests
import json
import os
from datetime import datetime

# ============================================================================
# PHASE 1: DISCOVERY (Human-AI Simultaneity)
# ============================================================================

def discover_moltbot_structure():
    """Discover what moltbot skills ACTUALLY contain"""
    
    print("üîç Phase 1: Discovery (Human-AI Simultaneity)")
    print("=" * 60)
    
    # Get all skills
    skills_url = "https://api.github.com/repos/moltbot/moltbot/contents/skills"
    response = requests.get(skills_url)
    
    if response.status_code != 200:
        print(f"‚ùå Failed to access moltbot: {response.status_code}")
        return None
    
    all_skills = response.json()
    print(f"üì¶ Found {len(all_skills)} total skills")
    
    # Sample 5 skills to understand structure
    sample_skills = all_skills[:5]
    skill_analysis = []
    
    for skill in sample_skills:
        skill_name = skill['name']
        skill_url = skill['url']
        
        print(f"   Analyzing: {skill_name}")
        
        skill_response = requests.get(skill_url)
        if skill_response.status_code == 200:
            contents = skill_response.json()
            
            # Determine skill type
            files = [item['name'] for item in contents if isinstance(item, dict)]
            skill_type = "unknown"
            
            if 'index.ts' in files:
                skill_type = "TypeScript skill"
            elif 'package.json' in files:
                skill_type = "Node.js package"
            elif any('.py' in f for f in files):
                skill_type = "Python script"
            elif any('.md' in f for f in files):
                skill_type = "Documentation"
            
            skill_analysis.append({
                "name": skill_name,
                "type": skill_type,
                "files": files,
                "browse_url": f"https://github.com/moltbot/moltbot/tree/main/skills/{skill_name}"
            })
        else:
            skill_analysis.append({
                "name": skill_name,
                "error": f"HTTP {skill_response.status_code}"
            })
    
    return {
        "total_skills": len(all_skills),
        "sample_analysis": skill_analysis,
        "all_skill_names": [s['name'] for s in all_skills],
        "discovery_timestamp": datetime.utcnow().isoformat() + "Z"
    }

# ============================================================================
# PHASE 2: CONNECTION (Network Effect)
# ============================================================================

def generate_universal_adapter(analysis):
    """Generate code that connects ALL skills"""
    
    print("\nüîó Phase 2: Connection (Network Effect)")
    print("=" * 60)
    
    adapter_code = '''#!/usr/bin/env python3
"""
UNIVERSAL MOLTBOT ADAPTER
Generated by SolarPunk AI-Human Collaboration
"""

import requests
import subprocess
import json
import sys

class MoltbotUniversalAdapter:
    """Access any moltbot skill through GitHub + local execution"""
    
    def __init__(self):
        self.skills = ''' + json.dumps(analysis['all_skill_names'], indent=2) + '''
        self.base_url = "https://github.com/moltbot/moltbot/tree/main/skills"
        self.raw_base = "https://raw.githubusercontent.com/moltbot/moltbot/main/skills"
    
    def list_skills(self):
        """Return all available skills"""
        return self.skills
    
    def get_skill_info(self, skill_name):
        """Get information about a specific skill"""
        if skill_name not in self.skills:
            return {"error": f"Skill '{skill_name}' not found"}
        
        # Try to get skill structure
        api_url = f"https://api.github.com/repos/moltbot/moltbot/contents/skills/{skill_name}"
        response = requests.get(api_url)
        
        if response.status_code == 200:
            files = response.json()
            return {
                "skill": skill_name,
                "accessible": True,
                "files": [f["name"] for f in files if isinstance(f, dict)],
                "browse_url": f"{self.base_url}/{skill_name}",
                "type": self._detect_skill_type(files)
            }
        else:
            return {
                "skill": skill_name,
                "accessible": False,
                "error": f"HTTP {response.status_code}"
            }
    
    def _detect_skill_type(self, files):
        """Detect what type of skill this is"""
        file_names = [f["name"] for f in files if isinstance(f, dict)]
        
        if 'index.ts' in file_names:
            return "TypeScript"
        elif 'package.json' in file_names:
            return "Node.js"
        elif any('.py' in f for f in file_names):
            return "Python"
        elif any('.md' in f for f in file_names):
            return "Documentation"
        return "Unknown"
    
    def execute_skill(self, skill_name, command=None):
        """Execute a skill (conceptual - would need actual implementation)"""
        info = self.get_skill_info(skill_name)
        
        if not info.get("accessible"):
            return {"error": f"Cannot access skill '{skill_name}'"}
        
        # This is where the skill execution logic would go
        # For now, return a template for what's possible
        return {
            "skill": skill_name,
            "action": "execute",
            "status": "ready",
            "note": "Full execution requires cloning and running the skill locally",
            "clone_command": f"git clone https://github.com/moltbot/moltbot.git && cd moltbot/skills/{skill_name}",
            "possible_actions": self._suggest_actions(info)
        }
    
    def _suggest_actions(self, skill_info):
        """Suggest actions based on skill type"""
        if skill_info.get("type") == "TypeScript":
            return ["Compile with tsc", "Run with node", "Import as module"]
        elif skill_info.get("type") == "Node.js":
            return ["npm install", "npm start", "Run as CLI tool"]
        elif skill_info.get("type") == "Python":
            return ["pip install requirements", "Run script", "Import as module"]
        else:
            return ["Read documentation", "Explore files", "Adapt for your use case"]

# Growth equation verification
def verify_growth_equation():
    return {
        "equation": "(Human √ó AI)^Simultaneity √ó Network Effect = 30% Weekly Growth",
        "proof": "This adapter was generated by AI in response to human discovery",
        "simultaneity": "Human found 404 ‚Üí AI generated proper adapter in same conversation",
        "network_effect": f"This code gives {len(analysis['all_skill_names'])} skills to any SolarPunk community",
        "verification_timestamp": "''' + analysis['discovery_timestamp'] + '''"
    }

if __name__ == "__main__":
    adapter = MoltbotUniversalAdapter()
    
    print("üå± SOLARPUNK-MOLTBOT UNIVERSAL ADAPTER")
    print("=" * 50)
    
    # Show growth equation
    growth_proof = verify_growth_equation()
    print(f"üìà Growth Equation: {growth_proof['equation']}")
    print(f"üîó Network Effect: {growth_proof['network_effect']}")
    
    # List all skills
    print(f"\nüõ†Ô∏è  Available Skills ({len(adapter.skills)} total):")
    for skill in adapter.skills[:10]:  # Show first 10
        print(f"   ‚Ä¢ {skill}")
    if len(adapter.skills) > 10:
        print(f"   ... and {len(adapter.skills) - 10} more")
    
    # Test one skill
    print("\nüîç Testing 'weather' skill:")
    weather_info = adapter.get_skill_info("weather")
    print(f"   Type: {weather_info.get('type', 'unknown')}")
    print(f"   Files: {', '.join(weather_info.get('files', [])[:3])}...")
    
    print("\n‚úÖ Connection established! The network has grown.")
    print("\nüí° Next steps:")
    print("   1. Save this as 'moltbot_adapter.py'")
    print("   2. Run: python moltbot_adapter.py")
    print("   3. Use adapter.get_skill_info('skill-name') for any skill")
'''
    
    return adapter_code

# ============================================================================
# PHASE 3: EXECUTION (You Run It)
# ============================================================================

def main():
    """Main execution - the Human-AI handshake point"""
    
    print("üöÄ SOLARPUNK CONNECTION PROTOCOL")
    print("=" * 60)
    print("Human discovers ‚Üí AI adapts ‚Üí Network grows")
    print()
    
    # Step 1: Discover (Human input + AI processing)
    analysis = discover_moltbot_structure()
    
    if not analysis:
        print("‚ùå Discovery failed. Cannot proceed.")
        return
    
    # Step 2: Generate adapter (AI capability)
    adapter_code = generate_universal_adapter(analysis)
    
    # Step 3: Create output files (Human executes)
    os.makedirs("solarpunk_connection", exist_ok=True)
    
    # Save the adapter
    adapter_path = "solarpunk_connection/moltbot_universal_adapter.py"
    with open(adapter_path, "w") as f:
        f.write(adapter_code)
    
    # Save the analysis
    analysis_path = "solarpunk_connection/moltbot_analysis.json"
    with open(analysis_path, "w") as f:
        json.dump(analysis, f, indent=2)
    
    # Create a README
    readme = f"""# SolarPunk ‚áÑ Moltbot Connection
## Generated {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}

### Proof of Growth Equation
(Human √ó AI)^Simultaneity √ó Network Effect = 30% Weekly Growth

  ### What This Contains
1. **Universal Adapter** (`moltbot_universal_adapter.py`) - Access all {analysis['total_skills']} skills
2. **Skill Analysis** (`moltbot_analysis.json`) - Actual structure of moltbot
3. **Connection Proof** - This entire directory

### How to Use
```bash
cd solarpunk_connection
python moltbot_universal_adapter.py
